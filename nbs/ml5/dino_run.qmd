---
title: "Dino Run - Control por Gestos"
description: "Un juego estilo Chrome Dino controlado con gestos usando Teachable Machine y ml5.js"
format: html
---

Este es un juego de dinosaurio corredor donde debes saltar sobre los obstáculos. En lugar de usar el teclado, el juego se controla mediante gestos capturados por tu cámara web usando un modelo de Teachable Machine.

**Instrucciones:**

- 1. Haz clic en el botón "Iniciar Juego"
- 2. Permite el acceso a tu cámara web cuando se te solicite
- 3. Para saltar, muestra una **mano abierta con la palma hacia la cámara y los dedos apuntando hacia arriba** (gesto "Jump")
- 4. Si el modelo no detecta el gesto correcto, el dinosaurio no saltará
- 5. Evita los obstáculos (árboles) para acumular puntos
- 6. El juego termina cuando chocas con un obstáculo

::: {.callout-note}
Este juego utiliza un modelo pre-entrenado de Teachable Machine. Asegúrate de tener buena iluminación para mejor detección de gestos.
:::

<div id="button-container" style="text-align: center; margin: 20px 0;">
  <button id="start-button" style="padding: 12px 24px; font-size: 16px; background-color: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">
    Iniciar Juego
  </button>
  <button id="reset-button" style="display: none; padding: 12px 24px; font-size: 16px; background-color: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 10px;">
    Reiniciar Juego
  </button>
  <button id="stop-button" style="display: none; padding: 12px 24px; font-size: 16px; background-color: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 10px;">
    Detener Juego
  </button>
  <p id="status-message" style="margin-top: 10px; font-style: italic; color: #666;"></p>
</div>

<div id="p5-sketch" style="display: none; text-align: center;">
  <div id="canvas-container" style="display: inline-block;"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/p5@1.11.7/lib/p5.js"></script>
<script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

<script>
// Wait for ml5 to be fully loaded
window.addEventListener('load', function() {
    if (typeof ml5 === 'undefined') {
        console.error('ml5 is not loaded');
        return;
    }

    const startButton = document.getElementById('start-button');
    const stopButton = document.getElementById('stop-button');
    const resetButton = document.getElementById('reset-button');
    const statusMessage = document.getElementById('status-message');
    const sketchContainer = document.getElementById('p5-sketch');
    let sketchStarted = false;
    let p5Instance = null;
    let videoStream = null;

    function startGame() {
        if (sketchStarted) return;
        
        sketchStarted = true;
        startButton.style.display = 'none';
        resetButton.style.display = 'inline-block';
        stopButton.style.display = 'inline-block';
        statusMessage.textContent = 'Cargando modelo y recursos...';
        
        sketchContainer.style.display = 'block';

        const sketch = (p) => {
            // Game objects
            let dino;
            let obstacles = [];
            let groundY = 300;

            // ML5 variables
            let classifier;
            let video;
            let movementLabel = '';

            // Game variables
            let count = 0;
            let gameOver = false;
            let gameStarted = false;
            let countdown = 3;
            let countdownTimer = 0;
            let lastObstacleFrame = 0;
            let minObstacleDistance = 80; // Minimum frames between obstacles

            // Images
            let imgDino;
            let imgTree;
            let imgExplosion;

            p.preload = function() {
                // Load images
                imgDino = p.loadImage("../data/images/dino_run/dino.png");
                imgTree = p.loadImage("../data/images/dino_run/tree.png");
                imgExplosion = p.loadImage("../data/images/dino_run/explosion.png");
                
                // Load Teachable Machine model
                classifier = ml5.imageClassifier('https://teachablemachine.withgoogle.com/models/Ij_wIPp5Q/model.json', modelLoaded);
            }

            function modelLoaded() {
                console.log('Model loaded!');
                statusMessage.textContent = '¡Modelo cargado! Preparando juego...';
            }

            p.setup = function() {
                p.createCanvas(800, 400);
                
                video = p.createCapture(p.VIDEO);
                video.size(160, 120);
                video.hide();
                videoStream = video;

                // Create the dino
                dino = new Dino(groundY);
                
                // Add the first obstacle
                obstacles.push(new Obstacle(groundY));

                statusMessage.textContent = 'Preparándose para iniciar...';
                statusMessage.style.color = '#FF9800';

                classifyVideo();
                
                // Start countdown
                countdownTimer = p.millis();
            }

            function classifyVideo() {
                if (!gameOver) {
                    classifier.classify(video, gotResults);
                }
            }

            function gotResults(error, results) {
                if (error) {
                    console.error(error);
                    return;
                }
                
                if (results && results.length > 0) {
                    movementLabel = results[0].label;
                }
                
                setModelGesture();
                classifyVideo();
            }

            function setModelGesture() {
                if (movementLabel === 'Jump') {
                    dino.jump();
                }
            }

            p.draw = function() {
                p.background(220);

                // Countdown logic
                if (!gameStarted && !gameOver) {
                    let elapsed = p.millis() - countdownTimer;
                    countdown = 3 - p.floor(elapsed / 1000);
                    
                    if (countdown <= 0) {
                        gameStarted = true;
                        statusMessage.textContent = '¡Juego iniciado! Haz el gesto "Jump" para saltar';
                        statusMessage.style.color = '#4CAF50';
                    }
                }

                // Update and draw the dinosaur
                dino.update();
                dino.show();

                // Display score
                p.textSize(32);
                p.textAlign(p.LEFT, p.TOP);
                p.fill(0);
                p.text(`Points: ${count}`, 10, 10);
                
                // Display hit points (hearts)
                p.textSize(20);
                let hearts = '';
                for (let i = 0; i < dino.getHitPoints(); i++) {
                    hearts += '❤️ ';
                }
                p.text(`HP: ${hearts}`, 10, 50);
                
                // Display gesture
                p.textSize(20);
                p.text(`Gesture: ${movementLabel}`, 10, 80);

                // Show countdown
                if (!gameStarted && !gameOver && countdown > 0) {
                    p.fill(255, 165, 0);
                    p.textSize(72);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.text(countdown, p.width/2, p.height/2);
                }

                // Only spawn obstacles and check collisions after countdown
                if (gameStarted && !gameOver) {
                    // Spawn obstacles with proper spacing
                    // Use random interval between 60-100 frames for variety
                    let framesSinceLastObstacle = p.frameCount - lastObstacleFrame;
                    let randomInterval = p.random(minObstacleDistance, minObstacleDistance + 40);
                    
                    if (framesSinceLastObstacle >= randomInterval) {
                        obstacles.push(new Obstacle(groundY));
                        lastObstacleFrame = p.frameCount;
                    }
                }

                // Update and draw each obstacle
                for (let i = obstacles.length - 1; i >= 0; i--) {
                    if (gameStarted) {
                        obstacles[i].update();
                    }
                    obstacles[i].show();

                    // Check collision only if game started
                    if (gameStarted && obstacles[i].hits(dino) && !gameOver) {
                        let isGameOver = dino.hit();
                        if (isGameOver) {
                            gameOver = true;
                            console.log("Game Over");
                            statusMessage.textContent = `¡Game Over! Puntos: ${count}, Saltos totales: ${dino.getTotalJumps()}`;
                            statusMessage.style.color = '#f44336';
                        }
                        // Remove the obstacle that hit the dino
                        obstacles.splice(i, 1);
                        continue;
                    }

                    // Remove offscreen obstacles
                    if (obstacles[i].offscreen()) {
                        if (gameStarted) {
                            count++;
                        }
                        obstacles.splice(i, 1);
                    }
                }

                // Draw the ground line
                p.stroke(0);
                p.line(0, groundY, p.width, groundY);

                // Draw webcam feed in top right corner
                p.push();
                p.translate(p.width - 165, 5); // Position in top right with 5px margin
                p.stroke(0);
                p.strokeWeight(3);
                p.fill(255);
                p.rect(0, 0, 160, 120);
                p.image(video, 0, 0, 160, 120);
                p.pop();

                // Show game over message
                if (gameOver) {
                    p.fill(0);
                    p.textSize(48);
                    p.textAlign(p.CENTER, p.CENTER);
                    p.text("GAME OVER", p.width/2, p.height/2 - 30);
                    p.textSize(24);
                    p.text(`Total Points: ${count}`, p.width/2, p.height/2 + 20);
                    p.text(`Total Jumps: ${dino.getTotalJumps()}`, p.width/2, p.height/2 + 50);
                }
            }

            // Dino class
            class Dino {
                constructor(groundY) {
                    this.r = 50;
                    this.x = 50;
                    this.groundY = groundY;
                    this.y = groundY - this.r;
                    this.vy = 0;
                    this.gravity = 1.0;
                    this.totalJumps = 0;
                    this.isDead = false;
                    this.hitPoints = 3;
                    this.invulnerable = false;
                    this.invulnerableTimer = 0;
                }

                jump() {
                    // Only jump if on the ground
                    if (this.y === this.groundY - this.r) {
                        this.totalJumps++;
                        this.vy = -18;
                    }
                }

                update() {
                    this.y += this.vy;
                    this.vy += this.gravity;

                    // Prevent falling below ground
                    if (this.y > this.groundY - this.r) {
                        this.y = this.groundY - this.r;
                        this.vy = 0;
                    }
                    
                    // Update invulnerability timer
                    if (this.invulnerable && p.millis() - this.invulnerableTimer > 2000) {
                        this.invulnerable = false;
                    }
                }

                hit() {
                    if (!this.invulnerable && !this.isDead) {
                        this.hitPoints--;
                        if (this.hitPoints <= 0) {
                            this.dead();
                            return true; // Game over
                        } else {
                            // Make invulnerable for 2 seconds after hit
                            this.invulnerable = true;
                            this.invulnerableTimer = p.millis();
                            return false; // Continue playing
                        }
                    }
                    return false;
                }

                dead() {
                    this.isDead = true;
                }

                show() {
                    // Flash when invulnerable
                    if (this.invulnerable && p.frameCount % 10 < 5) {
                        p.push();
                        p.tint(255, 100, 100); // Red tint when flashing
                        if (this.isDead) {
                            p.image(imgExplosion, this.x, this.y, this.r, this.r);
                        } else {
                            p.image(imgDino, this.x, this.y, this.r, this.r);
                        }
                        p.pop();
                    } else {
                        if (this.isDead) {
                            p.image(imgExplosion, this.x, this.y, this.r, this.r);
                        } else {
                            p.image(imgDino, this.x, this.y, this.r, this.r);
                        }
                    }
                }

                getTotalJumps() {
                    return this.totalJumps;
                }
                
                getHitPoints() {
                    return this.hitPoints;
                }
            }

            // Obstacle class
            class Obstacle {
                constructor(groundY) {
                    this.w = 20;
                    this.h = p.random(40, 80);
                    this.x = p.width;
                    this.groundY = groundY;
                    this.y = groundY - this.h;
                    this.speed = 3;
                }

                update() {
                    this.x -= this.speed;
                }

                offscreen() {
                    return this.x < -this.w;
                }

                show() {
                    p.image(imgTree, this.x, this.y, this.w, this.h);
                }

                hits(dino) {
                    // Simple rectangle collision detection
                    return (
                        dino.x < this.x + this.w &&
                        dino.x + dino.r > this.x &&
                        dino.y < this.y + this.h &&
                        dino.y + dino.r > this.y
                    );
                }
            }
        };
        
        p5Instance = new p5(sketch, 'canvas-container');
    }

    startButton.addEventListener('click', startGame);

    resetButton.addEventListener('click', function() {
        // Stop current instance
        if (videoStream) {
            videoStream.remove();
            videoStream = null;
        }
        
        if (p5Instance) {
            p5Instance.remove();
            p5Instance = null;
        }
        
        // Reset flag and restart
        sketchStarted = false;
        startGame();
    });

    stopButton.addEventListener('click', function() {
        if (videoStream) {
            videoStream.remove();
            videoStream = null;
        }
        
        if (p5Instance) {
            p5Instance.remove();
            p5Instance = null;
        }
        
        sketchContainer.style.display = 'none';
        stopButton.style.display = 'none';
        resetButton.style.display = 'none';
        startButton.style.display = 'inline-block';
        statusMessage.textContent = '';
        sketchStarted = false;
    });
});
</script>

## Código Completo

```javascript
// Game objects
let dino;
let obstacles = [];
let groundY = 300;

// ML5 variables
let classifier;
let video;
let movementLabel = '';

// Game variables
let count = 0;
let gameOver = false;
let gameStarted = false;
let countdown = 3;
let countdownTimer = 0;
let lastObstacleFrame = 0;
let minObstacleDistance = 80;

// Images
let imgDino;
let imgTree;
let imgExplosion;

function preload() {
    imgDino = loadImage("../data/images/dino_run/dino.png");
    imgTree = loadImage("../data/images/dino_run/tree.png");
    imgExplosion = loadImage("../data/images/dino_run/explosion.png");
    classifier = ml5.imageClassifier('https://teachablemachine.withgoogle.com/models/Ij_wIPp5Q/model.json');
}

function setup() {
    createCanvas(800, 400);
    
    video = createCapture(VIDEO);
    video.size(160, 120);
    video.hide();
    
    dino = new Dino(groundY);
    obstacles.push(new Obstacle(groundY));
    
    countdownTimer = millis();
    classifyVideo();
}

function classifyVideo() {
    if (!gameOver) {
        classifier.classify(video, gotResults);
    }
}

function gotResults(error, results) {
    if (error) {
        console.error(error);
        return;
    }
    
    if (results && results.length > 0) {
        movementLabel = results[0].label;
    }
    
    setModelGesture();
    classifyVideo();
}

function setModelGesture() {
    if (movementLabel === 'Jump') {
        dino.jump();
    }
}

function draw() {
    background(220);
    
    // Countdown logic
    if (!gameStarted && !gameOver) {
        let elapsed = millis() - countdownTimer;
        countdown = 3 - floor(elapsed / 1000);
        
        if (countdown <= 0) {
            gameStarted = true;
        }
    }
    
    // Update and draw the dinosaur
    dino.update();
    dino.show();
    
    // Display score
    textSize(32);
    textAlign(LEFT, TOP);
    fill(0);
    text(`Points: ${count}`, 10, 10);
    
    // Display hit points (hearts)
    textSize(20);
    let hearts = '';
    for (let i = 0; i < dino.getHitPoints(); i++) {
        hearts += '❤️ ';
    }
    text(`HP: ${hearts}`, 10, 50);
    
    // Display gesture
    textSize(20);
    text(`Gesture: ${movementLabel}`, 10, 80);
    
    // Show countdown
    if (!gameStarted && !gameOver && countdown > 0) {
        fill(255, 165, 0);
        textSize(72);
        textAlign(CENTER, CENTER);
        text(countdown, width/2, height/2);
    }
    
    // Spawn obstacles with proper spacing
    if (gameStarted && !gameOver) {
        let framesSinceLastObstacle = frameCount - lastObstacleFrame;
        let randomInterval = random(minObstacleDistance, minObstacleDistance + 40);
        
        if (framesSinceLastObstacle >= randomInterval) {
            obstacles.push(new Obstacle(groundY));
            lastObstacleFrame = frameCount;
        }
    }
    
    // Update and draw each obstacle
    for (let i = obstacles.length - 1; i >= 0; i--) {
        if (gameStarted) {
            obstacles[i].update();
        }
        obstacles[i].show();
        
        // Check collision
        if (gameStarted && obstacles[i].hits(dino) && !gameOver) {
            let isGameOver = dino.hit();
            if (isGameOver) {
                gameOver = true;
            }
            obstacles.splice(i, 1);
            continue;
        }
        
        // Remove offscreen obstacles
        if (obstacles[i].offscreen()) {
            if (gameStarted) {
                count++;
            }
            obstacles.splice(i, 1);
        }
    }
    
    // Draw the ground line
    stroke(0);
    line(0, groundY, width, groundY);
    
    // Draw webcam feed in top right corner
    push();
    translate(width - 165, 5);
    stroke(0);
    strokeWeight(3);
    fill(255);
    rect(0, 0, 160, 120);
    image(video, 0, 0, 160, 120);
    pop();
    
    // Show game over message
    if (gameOver) {
        fill(0);
        textSize(48);
        textAlign(CENTER, CENTER);
        text("GAME OVER", width/2, height/2 - 30);
        textSize(24);
        text(`Total Points: ${count}`, width/2, height/2 + 20);
        text(`Total Jumps: ${dino.getTotalJumps()}`, width/2, height/2 + 50);
    }
}

// Dino class
class Dino {
    constructor(groundY) {
        this.r = 50;
        this.x = 50;
        this.groundY = groundY;
        this.y = groundY - this.r;
        this.vy = 0;
        this.gravity = 1.5;
        this.totalJumps = 0;
        this.isDead = false;
        this.hitPoints = 3;
        this.invulnerable = false;
        this.invulnerableTimer = 0;
    }
    
    jump() {
        if (this.y === this.groundY - this.r) {
            this.totalJumps++;
            this.vy = -28;
        }
    }
    
    update() {
        this.y += this.vy;
        this.vy += this.gravity;
        
        if (this.y > this.groundY - this.r) {
            this.y = this.groundY - this.r;
            this.vy = 0;
        }
        
        if (this.invulnerable && millis() - this.invulnerableTimer > 2000) {
            this.invulnerable = false;
        }
    }
    
    hit() {
        if (!this.invulnerable && !this.isDead) {
            this.hitPoints--;
            if (this.hitPoints <= 0) {
                this.dead();
                return true;
            } else {
                this.invulnerable = true;
                this.invulnerableTimer = millis();
                return false;
            }
        }
        return false;
    }
    
    dead() {
        this.isDead = true;
    }
    
    show() {
        if (this.invulnerable && frameCount % 10 < 5) {
            push();
            tint(255, 100, 100);
            if (this.isDead) {
                image(imgExplosion, this.x, this.y, this.r, this.r);
            } else {
                image(imgDino, this.x, this.y, this.r, this.r);
            }
            pop();
        } else {
            if (this.isDead) {
                image(imgExplosion, this.x, this.y, this.r, this.r);
            } else {
                image(imgDino, this.x, this.y, this.r, this.r);
            }
        }
    }
    
    getTotalJumps() {
        return this.totalJumps;
    }
    
    getHitPoints() {
        return this.hitPoints;
    }
}

// Obstacle class
class Obstacle {
    constructor(groundY) {
        this.w = 20;
        this.h = random(40, 80);
        this.x = width;
        this.groundY = groundY;
        this.y = groundY - this.h;
        this.speed = 3;
    }
    
    update() {
        this.x -= this.speed;
    }
    
    offscreen() {
        return this.x < -this.w;
    }
    
    show() {
        image(imgTree, this.x, this.y, this.w, this.h);
    }
    
    hits(dino) {
        return (
            dino.x < this.x + this.w &&
            dino.x + dino.r > this.x &&
            dino.y < this.y + this.h &&
            dino.y + dino.r > this.y
        );
    }
}
```

